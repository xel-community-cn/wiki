<!-- TITLE: ePl Submitting Tasks -->

<!-- SUBTITLE: A quick summary of ePl Submitting Tasks -->

## #ePL-发布任务

是时候将您的任务发布到主网上了。 在此之前，我们强烈建议您能够阅读理解下下面的指南。 在这个教程指南里我们会使用之前的示例。 之前的代码只是本地测试用，而这次我们的任务将会被提交到主网并运行。

* * *

## 准备Xeline

当您完成ePL的任务编程，并且感觉已经准备好广播到XEL网络上，那么这个工具就派上用场了。 Xeline即是一个钱包，又可以让您轻松上传您的ePL文件到XEL主网，您要做的只是将文件拖放到钱包界面上的相应位置即可。 只需要几秒钟，XEL网络上的算力节点就会运行获取您想要的结果。 此外，这个钱包使您方便的打开任务并进行实时监控，收集获取并记录主网上其他节点的结果。

安装非常简单：

* [Windows系统 ](windows-xeline)

* 

[MacOS系统 ](mac-os-xeline)

* [Linux系统 ](linux-xeline)

* * *

## 准备ePL文件

本教程将会使用得演示任务（here）。 将它保存并命名为“my_own_prime_demo.epl”。 虽然这个示例已经集成进了Xeline钱包内，并且可以立即执行，但是，我们为了学习目的，将从头开始创建这个项目。 此时，您的ePL文件还只包含程序逻辑部分。 然而，想要提交到主网，你必须要配置几个参数，我们称之为“元数据”。 这些参数告诉Xeline您将付出的悬赏金额，任务的运行时间，您想要获取的结果数量，您的任务需要迭代多少次等等。 我们还没有涉及到迭代部分，这个以后再说。 元数据在ePL文件的头部增添。 那么，元数据的格式，参考下面的代码，并将它增添到您ePL程序的头部：

```java
// metadata(title:My personal PRIME demo)
// metadata(pow_limit:1000)
// metadata(pow_price:0.02)
// metadata(bounty_limit:1)
// metadata(bounty_price:5)
// metadata(iterations:1)
// metadata(timeout:250)
// metadata(callback:my_own_prime_demo_callback.js)
```

让我们在这里设置断点，并深入看下这些代码的功能:

```java
// metadata(title:My personal PRIME demo)
```

这一行是您任务的介绍。 尽量使用简短语句。 这个标签仅用于帮助您用于区分Xeline钱包内的任务，它们不会被提交到主网。

```java
// metadata(pow_limit:1000)
// metadata(pow_price:0.0001)
```

这两行代码用于介绍在工作超时和自动关闭之前，你愿意支付的工作量结算的金额。 请记住：这些以10次工作证明（POW）每秒的频率，对参与者进行持续的小额奖励（网络中所有任务一起）。 在我们的示例中，我们将支付1000份的工作量，每份的奖励为0.0001XEL，如果网络提交的结果，不是我们任务想要的，那么，我们将关闭任务，并且按照上面的金额进行结算。

```java
// metadata(bounty_limit:1)
// metadata(bounty_price:5)
```

上面的两行代码描述的是您希望获取的待解决问题的结果数量。 在我们的示例中，我们只寻找一个质数，所以我们设置这个值为1。 此外，我们将支付5XEL作为“赏金”，奖励给第一个提交正确结果的参与者。 如果有多个结果在同一个区块时间内被提交，那么，只有第一个出现的结果才会被记录和统计。 这是有可能发生的，原因很简单，任务的关闭和超时时间的触发在区块的处理之后。 也就是说，当您的任务获取到结果在第1000个区块时，那么任务将会在第1001个区块时关闭。 但是，由于我们永远不能确定哪些未确认事件将会写入下一个区块，所以，在第一个获取的结果被存放到高度为1000的区块的未确认事件缓存之前，我们还不能关闭任务。 当然，您不需要关注这种情况。 上面的讲解内容，主要针对的是那些已经提交了结果，没有获取他们的奖励，又想知道原因的参与者。

```java
// metadata(iterations:1)
```

此行告知Xeline您希望程序运行多少次迭代。 迭代的概念将在后面详细介绍：现在我们将它设置为1，这意味着您的程序将在#bounty_limit问题发现后立马结束。

```java
// metadata(timeout:250)
```

此行是告知Xeline,您想要结束任务的区块数，不论当前已经获取了多少结果或者完成了多少工作量证明。 此操作是非常有用的，例如，当您创建与时间有关结果的任务时（时间节点，终止条件等等，译者注）。 在本例种，我们只时将此值随意设置为250，这意味这任务将在250个区块后（从包含任务的区块开始计数）终止任务。

```java
// metadata(callback:my_own_prime_demo_callback.js)
```

此行可能是最重要的一条了，因为它将帮助您自动分析和获取参与者的节点提交的结果。 请记住，正如您在ePL编程指南种看到的，结果值储存12个伪随机整数型数组m[12]中。 不过，根据您获取结果的复杂程度，只查看数组，来获得想要的结果值，是不太现实的。 （分析获取结果值）这也就是我们所谓的回调的工作。

但只在元数据中进行回调是不够的，我们实际上需要在正确的位置上创建该文件。 该回调所用的脚本的防止目录，因系统而已。

**Windows**

```text
C:\Users\YourUserName\AppData\Local\Xeline\callbacks
```

**MacOS**

```text
~/Library/Application Support/Xeline/callbacks
```

**Linux**

```text
~/.config/Xeline/callbacks
```

因此，如果您使用得是macOS系统，那么您必须创建以下文件，此示例才能运行：

```text
~/Library/Application Support/Xeline/callbacks/my_own_prime_demo_callback.js
```

回调文件是用NodeJs编写的，且只能在您本地电脑上执行。 如前所述，它们的作用是为了更好的显示您处理并获取的结果值。 实际上，一旦结果被提交给区块，并在您任务检测的控制台中输出显示，那么Xeline钱包将运行此文件。 当然，您的回调文件也可以设定并执行各种其他的操作，例如，通过网络将此结果值发送给其他的应用程序。 现在，将此行写入文件中：

```text
console.log("Yeah. The blockchain just reported this prime: " + (bounties[0][0]>>>0));
```

在回调脚本中，可以访问名为bounties\[0\]\[0\]的二维数组。 第一个维度中包含已提交的所有结果，第二个维度包含12个产生此12个结果的m[]值。 由于我们只需要获取一个结果，所以，我们的bounty数组只包含12个无符号整数型变量：

```text
var bounties = [ [m[0],m[1],m[2],...m[11]] ];
```

由于我们的质数待选值保存于变量m\[0]（如果您不理解这一点，请再看下ePL编程指南），这样我们就可以得到变量bounties[0\]\[0\]的值，即数组m的第一个（唯一）值，也就是结果值。

此外，还有一个一维数组您也是可以访问的，即数组storages[]，它包含了最新的储存次数（结合上下文，译者注）。 由于我们还没有使用迭代和储存，此数组将为空，此示例将不再演示。

## **将任务提交至区块链**

现在，是时候将您的任务发布到主网上了。 为此，请点击左侧下部的“新建任务”以转到“新建任务”的界面。

现在，只需将“my_own_prime_demo.epl”文件拖到文件区域内：

您将看到一个确认界面，您可以在其中再次验证先前配置的所有元数据是否已正确配置。 此外，如果您没有将回调脚本放置在合适位置，那么，此步骤将通知您。 通过单击“广播”按钮，您就已经完成了将任务提交到区块链。 您将看到此确认信息，显示的是发送ID并建议您切换到任务概述：

点击左侧的“任务列表预览”或者“xx 任务列表”，可以切换到相应的任务预览。

由于任务上传到区块链，需要至少一个区块的确认，所以，任务有可能不会及时的显示。 所以，只需要等待几分钟，就会显示出来。 您将会看到至工作超时结束之前您任务的一些基础数据，其中有当前工作量证明的获取数量，及当前获取的的赏金（或结果），及任务的迭代和剩余的区块数。 此外，对于一些运行的任务，您将看到“取消”按钮，这可以使您随时终止您的任务。 在任务的数据下面，当任务执行完毕时，回调脚本将会被执行，然后您会看到一个信息：您任务的结果也就会出现。

这就是您任务完成后您的回调脚本被执行的样子： 

恭喜您！ 您已经成功地创建您的第一个ePL任务，提交任务至区块链，从“矿工”那里成功获取了结果，并且您的回调脚本正确的分析出您想要的结果。 您已经准备好继续学习迭代和储存的概念了。

`更新`